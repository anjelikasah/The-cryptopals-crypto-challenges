# The-cryptopals-crypto-challenges
<h2>Set 1</h2>
<h3>Challenge 1: Convert hex to base64</h3>
<p>Codecs is the library that encodes and decodes digital data stream or signal. To convert hex to base64, I have created a function which implements codecs. Here, codes.decode(hex_value,'hex'), decodes the hex string to normal text. And, codecs.encode('normal_value','base64').decode().rstrip() is used to encode the normal text to base64 value. Here decode() is used to get the string value after encoding and rstrip() is used to remove the new line from result.</p>
<h3>Challenge 2: Fixed XOR</h3>
<p>To get the XOR value of 2 hex values, I created a function xor which takes two hex values as input, converts them to integer, int(hex,16) and then performs XOR, a^b operation on them. Here, I used [2:] at the last of xor operation in order to crop the first two characters of hex value, 0x. If i used hex_final = hex(int1^int2) instead of hex_final = hex(int1^int2)[2:] then the result would be 0x746865206b696420646f6e277420706c6179 instead of 746865206b696420646f6e277420706c6179.</p>
<h3>Challenge 3: Single-byte XOR cipher</h3>
<p><ul><li>We are given a hex encoded string (say ciphertext) which has been XOR'd against a single character (say key). And we need to find out the original message.</li>
<li>Here, first the hex string is decoded and then XOR'd with all the printable in the function `get_xor`. Then the resulting message which is obtained after XORing is sent to function, `get_score` to calculate the score of that sentence in an English plaintext. And the message with highest score is output along with the key and score.</li></ul></p>
<h3>Challenge 4: Detect single-character XOR</h3>
<p>This challenge is similar to the earlier one, except, for this challenge we are given a file with 327 lines of hex string (ciphertext). This means, we need to run the above loop 327 times. For that, I created a saved the lines in a file named 4_resource.txt. And checked each line to get the maximum score on the original message. Here, the score is compared with other lines too, and the message,key and score with highest score is output.</p>
<h3>Challenge 5: Implement repeating-key XOR</h3>
<p>In this challenge, we need to encrypt the English language using repeated key XOR. We have the key, ICE. To match the length of key and sentence, I repeated the key, 1/3 times the length of sentence using function repeat_key. Roughly, key has more characters than the sentence. Then, I XOR'd each byte in key and sentence respectively using function get_xor.</p>
<h3>Challenge 6: Break repeating-key XOR</h3>
<p>
<ul><li>The file given here is base64'd after being encrypted with repeating-key XOR. To solve these, we have some steps to follow.</li>
<li>First we need to find the keysize (suggested is from 2 to 40). The function, find_possible_key_sizes in the code below, finds the 3 most probable key sizes. To do that, the function divides the decoded text (ciphertext) into chunks into the size equal to respective key size, takes the first 4 chunks and gets hamming distance between each 2 pairs. Then the hamming distance is averaged and normalized and stored in a dictionary for each key sizes. Finally the 3 keysizes with least normalized hamming distance is returned.</li>
<li>Hamming distance is calculated by the function, hamming_distance. 2 chunks are input in this function. It divides the chunks into bytes and then does XOR operation to find the difference in bits of those bytes. The total number of different bits are returned as hamming distance.</li>
<li>Now that we have the keysizes, we need to break the ciphertext into blocks of keysize length. This is done by the function, find_possible_plaintext. For all the 3 possible key sizes, one at a time, the whole ciphertext is broken into blocks of length equal to keysize. i-th byte from each block is transposed to a block and sent to get_single_char_xor to get single character key for the i-th position. Once keys for all the respective bytes are calculated, they are combined as a single key and sent to repeating_key_xor along with the ciphertext to get the original message. Lastly, the message and key is returned.</li>
<li>get_single_char_xor calculates the single character key for the supplied ciphertext. repeating_key_xor decrypts the ciphertext against the key to return original message. It uses a sequence of key on cycle mode to perform XOR operation over the whole ciphertext, byte by byte. </li>
</ul
</p>
<h3>Challenge 7: AES in ECB mode</h3>
<p>The file in this challenge is b64 encoded after it is encrypted via AES-128 in ECB mode under the key, "YELLOW SUBMARINE". To decrypt this, we need to use library, pycryptodome. From this library, we can import AES (Advanced Encryption Standard) module. Key of AES is 16, 24 or 32 byte long. For AES-128, it is 16 bytes long. In the code, decipher = AES.new (key, AES.MODE_ECB), new function returns an object of class, AESCipher which provides the function to both encrypt and decrypt the data. Using the above code, we created an AESCipher object. Now we can use this object to decrypt the ciphertext we have by calling the decrypt method as in decipher.decrypt(ciphertext). </p>
<h3>Challenge 8: Detect AES in ECB mode</h3>
<p>ECB always produce the same 16 bytes ciphertext for same 16 bytes plain text block. We can use this to find the line that has repeated block of ciphertext and hence, encrypted with ECB. First, I divided all the lines into respective chunks of size 16 bytes using function make_chunk. Then, I found the repeated chunk using function, find_repeated_chunk and the number of their occurrence in the line. Only one line had duplicate chunks and they were repeated 3 times (i.e. 4 occurrence of the same chunk). None of the chunks of other lines were repeated at least once. </br> Hence, d880619740a8a19b7840a8a31c810a3d08649af70dc06f4fd5d2d69c744cd283e2dd052f6b641dbf9d11b0348542bb5708649af70dc06f4fd5d2d69c744cd2839475c9dfdbc1d46597949d9c7e82bf5a08649af70dc06f4fd5d2d69c744cd28397a93eab8d6aecd566489154789a6b0308649af70dc06f4fd5d2d69c744cd283d403180c98c8f6db1f2a3f9c4040deb0ab51b29933f2c123c58386b06fba186a must be encrypted with ECB.</p>
</br>
<h2>Set 2</h2>
<h3>Challenge 9: Implement PKCS#7 padding</h3>
<p>In PKCS#7 padding, the value of each added byte is the number of bytes that are added, i.e. N bytes, each of value N are added. For eg, if 1 byte is to be added, it adds, 01; if 2 bytes is to be added, 02 02; if 5 bytes, 05 05 05 05 05; if 10 bytes, 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a. Each byte is in hex. And if the length of block is equal to block_size then the message is padded with full set of block size.</p>
<h3>Challenge 10: Implement CBC mode</h3>
<p>CBC mode allows us to encrypt irregularly-sized message. In CBC mode, each ciphertext block is added to the next plaintext block before the next call to the cipher core. The first plaintext block, which has no associated previous ciphertext block, is added to a "fake 0th ciphertext block" called the initialization vector, or IV.</p>
<p>For this challenge, I have created a function, `AES_CBC_decrypt` where CBC decryption happens. Here, the chunks of ciphertext are decrypted under `AES_128_ECB_decrypt` just like in Challenge 7. And then they are XOR'd with encrypted block of previous block (if its the first block then, with IV).</p>
<p>In this challenge, we also need to prepare CBC encryption, to verify the decryption by decryption whatever we want. To encrypt, I created another function, AES_CBC_encrypt where the bytes are padded and then chunked into the size of key. Then each block is XOR'd with the last block and then encrypted with ECB under the key, YELLOW SUBMARINE. This function uses AES_128_ECB_encrypt to encrypt the blocks under the key.</p>
<h3>Challenge 11: An ECB/CBC detection oracle</h3>
<ul><li>In this challenge, we are asked to generate a random AES key. I used the function, randon_key_generator that generates random hex key of given size (16 bytes for now). </li>
  <li>Next we need to write a function that encrypts data under the random unknown key. For that, I have used encryption_oracle function. Here, a random key is generated first. Then the plaintext is appended, before and after, with some random values of size 5 to 10 bytes. After the plaintext is padded, its either encrypted with ecb or with cbc on the basis of value generated by randit. The IV for cbc is also a random key of size 16 bytes. </li>
  <li>To detect the block cipher mode, I have created another function detection_oracle which checks for repeating chunks. If there are any, it returns string indicating 'ecb' else 'cbc'.</li>
  </ul>
 <h3>Challenge 12: Byte-at-a-time ECB decryption (Simple)</h3>
 <p>
<ul>
  <li>We have a function, encryption_oracle which is remake of the function from earlier challenge. This function uses a constant but unknown key to encrypt the binary buffer appended with the unknown string that we are provided in the challenge. ECB encryption is done in this function.</li>
  <li>The unknown string is base64 encoded and then appended to the binary buffer. Now we have the ciphertext which is base64 encoded and unknown but constant key.</li>
  <li>To decrypt this string, we need to make repeated call to the encryption_oracle function on the basis of binary buffer. Initially binary buffer is bytes([0]*64), i.e. hex 0 repeated 64 times.</li>
  <li>To discover the block size of the ciphertext, I have created a function, detect_size which gradually appends character 'A' to the binary buffer and sends to the encryption_oracle function. After encryption, it checks the size of the encrypted ciphertext. Because of padding, the length of this new ciphertext would not vary from the original one. It was 208. After few gradual implementation of the character, A, there was huge change in size all at once i.e. 224. The difference between length of new ciphertext and old is 16. This is how we came to know the  block size of the ciphertext.</li>
  <li>To detect that the encrypted function is using ECB, I used the function from previous challenge, detection_oracle.</li>
  <li>make_input_block is used to create block of given size with byte characters, A. We have to create blocks of length less than the block size on respective iteration. This function returns input block.</li>
  <li>Next, we have to create dictionary that appends characters to the input block one at a time. make_dictionary points to the appended input block on the basis of character.</li>
  <li>Now that we have everything all set, we can decrypt the unknown string byte at a time using function, byte_at_a_time_ECB_decryption. Here the random key is generate, ciphertext for initial binary buffer appended with the unknown string is calculated and the block size of that ciphertext is also calculated using functions explained earlier. Now the unknown string is chunked into the block of length equal to the block size.</li>
  <li>For every chunks of the unknown string, this function creates input string and its corresponding dictionary. It then encrypts the input block appended with the respective chunk of unknown string. And compares this encrypted ciphertext with the one that resulted after the encryption of dictionary. The character that gives the same result is output character that we need to find.</li>
  <li>For eg. for the first chunk of unknown string, i.e. 16 characters of unknown string; input block of size 15 is created and a dictionary is created which appends input block to each character in printable string (the size being 16). Input block is the appended with the chunk of unknown byte. And then the first block of this appended input block (block size is 16) is encrypted. Here, input block initially was AAAAAAAAAAAAAAAA. And after appending with unknown string, an extra character got introduced in this chain. Since we have dictionary of size 16 which also has A as first 15 bytes, and the input_block_ciphertext of length 16, we can compare them to get the last character in the input_block. This way we get the first character of the unknown string. </li>
  <li>For the second character, the input block size is reduced by 1, i.e. only 14 As.  The 15th character is the first character that we received earlier from the loop. And the same process is continued to find the character in 16th place. This way we get all the characters of first chunk. On repeating this for the rest of the chunks, we get the rest of the characters.</li>
 </ul
</p>
