# The-cryptopals-crypto-challenges
<h2>Set 1</h2>
<h3>Challenge 1: Convert hex to base64</h3>
<p>Codecs is the library that encodes and decodes digital data stream or signal. To convert hex to base64, I have created a function which implements codecs. Here, codes.decode(hex_value,'hex'), decodes the hex string to normal text. And, codecs.encode('normal_value','base64').decode().rstrip() is used to encode the normal text to base64 value. Here decode() is used to get the string value after encoding and rstrip() is used to remove the new line from result.</p>
<h3>Challenge 2: Fixed XOR</h3>
<p>To get the XOR value of 2 hex values, I created a function xor which takes two hex values as input, converts them to integer, int(hex,16) and then performs XOR, a^b operation on them. Here, I used [2:] at the last of xor operation in order to crop the first two characters of hex value, 0x. If i used hex_final = hex(int1^int2) instead of hex_final = hex(int1^int2)[2:] then the result would be 0x746865206b696420646f6e277420706c6179 instead of 746865206b696420646f6e277420706c6179.</p>
<h3>Challenge 3: Single-byte XOR cipher</h3>
<p><ul><li>We are given a hex encoded string (say ciphertext) which has been XOR'd against a single character (say key). And we need to find out the original message.</li>
<li>Here, first the hex string is decoded and then XOR'd with all the printable in the function `get_xor`. Then the resulting message which is obtained after XORing is sent to function, `get_score` to calculate the score of that sentence in an English plaintext. And the message with highest score is output along with the key and score.</li></ul></p>
<h3>Challenge 4: Detect single-character XOR</h3>
<p>This challenge is similar to the earlier one, except, for this challenge we are given a file with 327 lines of hex string (ciphertext). This means, we need to run the above loop 327 times. For that, I created a saved the lines in a file named 4_resource.txt. And checked each line to get the maximum score on the original message. Here, the score is compared with other lines too, and the message,key and score with highest score is output.</p>
<h3>Challenge 5: Implement repeating-key XOR</h3>
<p>In this challenge, we need to encrypt the English language using repeated key XOR. We have the key, ICE. To match the length of key and sentence, I repeated the key, 1/3 times the length of sentence using function repeat_key. Roughly, key has more characters than the sentence. Then, I XOR'd each byte in key and sentence respectively using function get_xor.</p>
<h3>Challenge 6: Break repeating-key XOR</h3>
<p>
<ul><li>The file given here is base64'd after being encrypted with repeating-key XOR. To solve these, we have some steps to follow.</li>
<li>First we need to find the keysize (suggested is from 2 to 40). The function, find_possible_key_sizes in the code below, finds the 3 most probable key sizes. To do that, the function divides the decoded text (ciphertext) into chunks into the size equal to respective key size, takes the first 4 chunks and gets hamming distance between each 2 pairs. Then the hamming distance is averaged and normalized and stored in a dictionary for each key sizes. Finally the 3 keysizes with least normalized hamming distance is returned.</li>
<li>Hamming distance is calculated by the function, hamming_distance. 2 chunks are input in this function. It divides the chunks into bytes and then does XOR operation to find the difference in bits of those bytes. The total number of different bits are returned as hamming distance.</li>
<li>Now that we have the keysizes, we need to break the ciphertext into blocks of keysize length. This is done by the function, find_possible_plaintext. For all the 3 possible key sizes, one at a time, the whole ciphertext is broken into blocks of length equal to keysize. i-th byte from each block is transposed to a block and sent to get_single_char_xor to get single character key for the i-th position. Once keys for all the respective bytes are calculated, they are combined as a single key and sent to repeating_key_xor along with the ciphertext to get the original message. Lastly, the message and key is returned.</li>
<li>get_single_char_xor calculates the single character key for the supplied ciphertext. repeating_key_xor decrypts the ciphertext against the key to return original message. It uses a sequence of key on cycle mode to perform XOR operation over the whole ciphertext, byte by byte. </li>
</ul
</p>
<h3>Challenge 7: AES in ECB mode</h3>
<p>The file in this challenge is b64 encoded after it is encrypted via AES-128 in ECB mode under the key, "YELLOW SUBMARINE". To decrypt this, we need to use library, pycryptodome. From this library, we can import AES (Advanced Encryption Standard) module. Key of AES is 16, 24 or 32 byte long. For AES-128, it is 16 bytes long. In the code, decipher = AES.new (key, AES.MODE_ECB), new function returns an object of class, AESCipher which provides the function to both encrypt and decrypt the data. Using the above code, we created an AESCipher object. Now we can use this object to decrypt the ciphertext we have by calling the decrypt method as in decipher.decrypt(ciphertext). </p>
<h3>Challenge 8: Detect AES in ECB mode</h3>
<p>ECB always produce the same 16 bytes ciphertext for same 16 bytes plain text block. We can use this to find the line that has repeated block of ciphertext and hence, encrypted with ECB. First, I divided all the lines into respective chunks of size 16 bytes using function make_chunk. Then, I found the repeated chunk using function, find_repeated_chunk and the number of their occurrence in the line. Only one line had duplicate chunks and they were repeated 3 times (i.e. 4 occurrence of the same chunk). None of the chunks of other lines were repeated at least once. </br> Hence, d880619740a8a19b7840a8a31c810a3d08649af70dc06f4fd5d2d69c744cd283e2dd052f6b641dbf9d11b0348542bb5708649af70dc06f4fd5d2d69c744cd2839475c9dfdbc1d46597949d9c7e82bf5a08649af70dc06f4fd5d2d69c744cd28397a93eab8d6aecd566489154789a6b0308649af70dc06f4fd5d2d69c744cd283d403180c98c8f6db1f2a3f9c4040deb0ab51b29933f2c123c58386b06fba186a must be encrypted with ECB.</p>
</br>
<h2>Set 2</h2>
<h3>Challenge 9: Implement PKCS#7 padding</h3>
<p>In PKCS#7 padding, the value of each added byte is the number of bytes that are added, i.e. N bytes, each of value N are added. For eg, if 1 byte is to be added, it adds, 01; if 2 bytes is to be added, 02 02; if 5 bytes, 05 05 05 05 05; if 10 bytes, 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a. Each byte is in hex. And if the length of block is equal to block_size then the message is padded with full set of block size.</p>
<h3>Challenge 10: Implement CBC mode</h3>
<p>CBC mode allows us to encrypt irregularly-sized message. In CBC mode, each ciphertext block is added to the next plaintext block before the next call to the cipher core. The first plaintext block, which has no associated previous ciphertext block, is added to a "fake 0th ciphertext block" called the initialization vector, or IV.</p>
<p>For this challenge, I have created a function, `AES_CBC_decrypt` where CBC decryption happens. Here, the chunks of ciphertext are decrypted under `AES_128_ECB_decrypt` just like in Challenge 7. And then they are XOR'd with encrypted block of previous block (if its the first block then, with IV).</p>
<p>In this challenge, we also need to prepare CBC encryption, to verify the decryption by decryption whatever we want. To encrypt, I created another function, AES_CBC_encrypt where the bytes are padded and then chunked into the size of key. Then each block is XOR'd with the last block and then encrypted with ECB under the key, YELLOW SUBMARINE. This function uses AES_128_ECB_encrypt to encrypt the blocks under the key.</p>
<h3>Challenge 11: An ECB/CBC detection oracle</h3>
<ul><li>In this challenge, we are asked to generate a random AES key. I used the function, randon_key_generator that generates random hex key of given size (16 bytes for now). </li>
  <li>Next we need to write a function that encrypts data under the random unknown key. For that, I have used encryption_oracle function. Here, a random key is generated first. Then the plaintext is appended, before and after, with some random values of size 5 to 10 bytes. After the plaintext is padded, its either encrypted with ecb or with cbc on the basis of value generated by randit. The IV for cbc is also a random key of size 16 bytes. </li>
  <li>To detect the block cipher mode, I have created another function detection_oracle which checks for repeating chunks. If there are any, it returns string indicating 'ecb' else 'cbc'.</li>
  </ul>
